#!/bin/sh /etc/rc.common

# This tells the system to use the procd functions
USE_PROCD=1

# --- Boot priority (99 is late, which is good for network-dependent scripts) ---
START=99

# --- This is the full path to our new monitoring script ---
SCRIPT_PATH="/usr/sbin/connection_monitor.sh"

start_service() {
    # Check if the script exists and is executable before starting
    if [ ! -f "$SCRIPT_PATH" ]; then
        echo "Error: Script $SCRIPT_PATH not found."
        # Use logger for consistency with the main script
        logger -t "ConnMon_Init" -p daemon.err "Startup failed: Script $SCRIPT_PATH not found."
        return 1
    elif [ ! -x "$SCRIPT_PATH" ]; then
        echo "Error: Script $SCRIPT_PATH is not executable. Run 'chmod +x $SCRIPT_PATH'."
        logger -t "ConnMon_Init" -p daemon.err "Startup failed: Script $SCRIPT_PATH is not executable."
        return 1
    fi

    procd_open_instance
    procd_set_param command "$SCRIPT_PATH"

    # This is the proven automatic restart logic from your working example.
    # It will restart the script if it crashes.
    # respawn [threshold] [timeout] [retry]
    procd_set_param respawn 3600 5 5

    # Redirect stdout/stderr to the system log (logd) so you can see any output with 'logread'
    procd_set_param stdout 1
    procd_set_param stderr 1

    procd_close_instance
}

# The stop_service function is handled automatically by procd when USE_PROCD=1
# The reload_service function can be added if needed, but for a simple loop, it's not necessary.

    
